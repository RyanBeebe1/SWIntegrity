
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;


public class CppExternallyControlledFormatStringVulnerability implements Vulnerability{
	
	public static void main(String[] args)
	{
		
		
	}
	
	public List<Integer> run(Analyzer ana){
		//convert analyzer to appropriate Type
		CppAnalyzer cppana = (CppAnalyzer)ana;
		// exploitable functions
		String printFunctions [] = {"printf", "fprintf", "fprint", "sprintf", "snprintf", "vfprintf", "vprintf", "vsprintf", "vsnprintf"};
		 
		String fileContents = cppana.getFileContents();
		System.out.println(fileContents);
		
		fileContents.toLowerCase();
		
		String[] temp=fileContents.split(" ");
		
		HashSet<Integer> vulnLines = new HashSet<>();
		/*
		for(String key: printFunctions)
		{
			if(fileContents.contains(key))
			{
				for(Map.Entry<String, ArrayList<Integer>> e:cppana.getSymbolToLine().entrySet())
				{
					if(e.getKey().toLowerCase().contains(key)) {
						
						vulnLines.addAll(e.getValue());
					}
				}
		}
		*/
		// TEST THIS VERSION
		/*
		for (String key : printFunctions) {
			
			//if the file contains those keywords and it doesn't use a regex for a whitelist
			if (fileContents.contains(key)) {
				//add the line number 
				for(Entry<Integer, Integer> e: cppana.getSymbolToLine().entrySet()) {
					if(e.getKey().toString().contains(key)) {
						
						vulnLines.add(e.getValue());
					}
				}
			}
		}
		*/
		
		for(String key: printFunctions)
		{
			if(fileContents.contains(key))
			{
				for(int index = 0; index <temp.length; index++)
				{
					if(temp[index].contains(key))
					{
						vulnLines.add(cppana.getSymbolToLine().get(index));
					}
				}
			}
		}
		/*
		boolean present = cppana.literalContains("printf");
		if(present == true)
		{
			System.out.println("Detected");
		}
		*/
		
		List<Integer> lines=new LinkedList<>();
		for(Integer number:vulnLines) {
			lines.add(number);
		}
		return lines;
		//return vulnLines;
	}
	
	
	
	
	
}
