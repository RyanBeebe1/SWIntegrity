import java.math.BigInteger;
import java.util.*;

public class JavaIntegerOverflowVulnerability implements Vulnerability {
    @Override
    public List<Integer> run(Analyzer ana) {

        JavaAnalyzer jana = (JavaAnalyzer) ana;
        List<Integer> locations = new ArrayList<>();
        String rawData = jana.getRawContents();

        rawData = rawData.replaceAll(" ", "");

        for (JavaAnalyzer.Variable v : jana.getVariables()) {
            if (v.getType().equals("int")) {
                int prevassnum = 0; //keep track of previous assignment
                for (HashMap.Entry<Integer, String> e : v.getAssignments().entrySet()) {
                    if (jana.getNON_ALPHA_NUMERIC().matcher(e.getValue()).find()) {
                        String temp = jana.getBetweenLines(prevassnum, e.getKey());
                        temp = temp.replaceAll("[()\\s]", "");
                        if (!(temp.contains(e.getValue().replaceAll("\\s", "").trim() + "<Integer.MAX_VALUE") && temp.contains(v.getName())
                                && temp.contains("long") || temp.contains(v.getName()) && rawData.contains(e.getValue().replaceAll(" ", "") + ">Integer.MIN_VALUE"))) {
                            locations.add(e.getKey());
                        }
                    }
                    if (e.getKey() > prevassnum)
                        prevassnum = e.getKey();
                    else
                        prevassnum = v.getLine();
                }
            } else if (v.getType().equals("char")) {
                int prevassnum = 0;
                for (HashMap.Entry<Integer, String> e : v.getAssignments().entrySet()) {
                    if (jana.getNON_ALPHA_NUMERIC().matcher(e.getValue()).find()) {
                        String temp = jana.getBetweenLines(prevassnum, e.getKey());
                        temp = temp.replaceAll("[()\\s]", "");
                        if (!(temp.contains(e.getValue().replaceAll("\\s", "").trim() + "<Character.MAX_VALUE") && temp.contains(v.getName())
                                || temp.contains(v.getName()) && rawData.contains(e.getValue().replaceAll(" ", "") + ">Character.MIN_VALUE"))) {
                            locations.add(e.getKey());
                        }
                    }
                    prevassnum = e.getKey();
                }
            } else if (v.getType().equals("byte")) {
                int prevassnum = 0;
                for (HashMap.Entry<Integer, String> e : v.getAssignments().entrySet()) {
                    if (jana.getNON_ALPHA_NUMERIC().matcher(e.getValue()).find()) {
                        String temp = jana.getBetweenLines(prevassnum, e.getKey());
                        temp = temp.replaceAll("[()\\s]", "");
                        if (!(temp.contains(e.getValue().replaceAll("\\s", "").trim() + "<Byte.MAX_VALUE") && temp.contains(v.getName())
                                || temp.contains(v.getName()) && rawData.contains(e.getValue().replaceAll(" ", "") + ">Byte.MIN_VALUE"))) {
                            locations.add(e.getKey());
                        }
                    }
                    prevassnum = e.getKey();
                }
            } else if (v.getType().equals("short")) {
                int prevassnum = 0;
                for (HashMap.Entry<Integer, String> e : v.getAssignments().entrySet()) {
                    if (jana.getNON_ALPHA_NUMERIC().matcher(e.getValue()).find()) {
                        String temp = jana.getBetweenLines(prevassnum, e.getKey());
                        temp = temp.replaceAll("[()\\s]", "");
                        if (!(temp.contains(e.getValue().replaceAll("\\s", "").trim() + "<Short.MAX_VALUE") && temp.contains(v.getName())
                                || temp.contains(v.getName()) && rawData.contains(e.getValue().replaceAll(" ", "") + ">Short.MIN_VALUE"))) {
                            locations.add(e.getKey());
                        }
                    }
                    prevassnum = e.getKey();
                }
            }
        }
        Collections.sort(locations);
        return locations;
    }

    
}
