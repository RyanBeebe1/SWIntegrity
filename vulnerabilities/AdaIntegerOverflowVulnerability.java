import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.math.BigInteger;

/**
 * Contains the code for the Ada implementation of the Integer Overflow Vulnerability.
 * #24 CWE-190: http://cwe.mitre.org/top25/#CWE-190
 * 
 * @author Ryan Beebe
 * 
 * <p>: Parses through the file looking for any place where an integer, double, char, uint_8, uint_16, etc...
 * is given a value. If that value is a number this class will check to see if that number is out of bounds or
 * if it is not a number it will check to see if the number/ variable/ arithmetic expression is first checked
 * for being out of bounds before being assigned to the variable </p>
 */
public class AdaIntegerOverflowVulnerability implements Vulnerability {

	@Override
	public List<Integer> run(Analyzer ana) {
			List<Integer> intOverflowList = new ArrayList<>();
			Map<Integer, String> assignments;
			String nonNumericValue = null;
			
			AdaAnalyzer adana=(AdaAnalyzer)ana;
			String fileContents = adana.getFileContents();
			for (AdaAnalyzer.Variable var: adana.variables.values())
			{
				
				switch (var.getType()) {
				case "Character":
					assignments = var.getAssignments();
					for(Map.Entry<Integer, String> assignment : assignments.entrySet()) {
						try { //Tests to see if the variable was given an assignment greater then the max or less then the min value
							  // if it was given a numeric value
							BigInteger value = new BigInteger(assignment.getValue());
							
							if (value.toString().compareTo("255") > 0 || value.toString().compareTo("-127") < 0)
								intOverflowList.add(assignment.getKey());
						}
						catch(NumberFormatException e)
						{
							nonNumericValue = assignment.getValue();
							//Check if the char has greater then one element. if it does you are looking at an expression. if not you are looking at a single character
							if (nonNumericValue.length() > 1) {
								String[] words = fileContents.split(var.name + " := " +assignment.getValue());
								if (!words[0].contains(nonNumericValue + " < =  255") || !words[0].contains(nonNumericValue + " < - 127")) {
									intOverflowList.add(assignment.getKey());
								} 
							}
						}
						
					}
					break;
				
				case "Natural":
					assignments = var.getAssignments();
					for(Map.Entry<Integer, String> assignment : assignments.entrySet()) {
						
						try {
							BigInteger value = new BigInteger(assignment.getValue());
							if (value.toString().compareTo("2147483647") > 0 || value.toString().compareTo("0") < 0) {
								intOverflowList.add(assignment.getKey());
							}
						}
						catch(NumberFormatException e)
						{
							nonNumericValue = assignment.getValue();
							String[] words = fileContents.split(var.name + " := " +assignment.getValue());
							//checks if the expression was ever checked against the max or min value for the respective data type
							//TODO Add more ways to handle this
							if (!words[0].contains(nonNumericValue + " < =  32767") || !words[0].contains(nonNumericValue + " < - 32767")) {
								intOverflowList.add(assignment.getKey());
							} 
						}
						
					}
					break;
					
				case "Integer":
					assignments = var.getAssignments();
					for(Map.Entry<Integer, String> assignment : assignments.entrySet()) {
						try {
							BigInteger value = new BigInteger(assignment.getValue().trim());
							BigInteger max = BigInteger.valueOf(Integer.MAX_VALUE);
							BigInteger min = BigInteger.valueOf(Integer.MIN_VALUE);
							if (value.compareTo(max) == 1 || value.compareTo(min) == -1) {
								intOverflowList.add(assignment.getKey());
							}
						}
						catch(NumberFormatException e)
						{
							nonNumericValue = assignment.getValue();
							String[] words = fileContents.split(var.name + " := " +assignment.getValue());
							if (!words[0].contains(nonNumericValue + " >  2147483647") || !words[0].contains(nonNumericValue + " < - 2147483648")) {
								intOverflowList.add(assignment.getKey());
							}
						}
						
					}
					break;

					
				case "Positive":
					assignments = var.getAssignments();
					for(Map.Entry<Integer, String> assignment : assignments.entrySet()) {
						try {
							BigInteger value = new BigInteger(assignment.getValue());
							if (value.toString().compareTo("2147483647") > 0 || value.toString().compareTo("1") < 0)
								intOverflowList.add(assignment.getKey());
						}
						catch(NumberFormatException e)
						{
							nonNumericValue = assignment.getValue();
							String[] words = fileContents.split(var.name + " := " +assignment.getValue());
							if (!words[0].contains(nonNumericValue + " >  2147483647") || !words[0].contains(nonNumericValue + " < - 2147483648")) {
								intOverflowList.add(assignment.getKey());
							}
						}
						
					}
					break;
				}
			}
			return intOverflowList;
	}

}

